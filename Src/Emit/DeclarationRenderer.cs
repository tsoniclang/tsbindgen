using System.Text;
using GenerateDts.Model;
using GenerateDts.Pipeline;
using GenerateDts.Emit.Writers;

namespace GenerateDts.Emit;

/// <summary>
/// Orchestrates the rendering of TypeScript declaration files.
/// Delegates to specialized writer modules for specific rendering tasks.
/// </summary>
public sealed class DeclarationRenderer
{
    /// <summary>
    /// Generates the content for the _intrinsics.d.ts file containing branded numeric types.
    /// This file should be created once in the output directory and referenced by all other declarations.
    /// </summary>
    public static string RenderIntrinsics()
    {
        return IntrinsicsWriter.RenderIntrinsics();
    }

    public string RenderDeclarations(ProcessedAssembly assembly, DependencyTracker? dependencyTracker = null)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine($"// Auto-generated by generatedts on {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss}Z - do not edit by hand.");
        sb.AppendLine();

        // ESM import for branded types from intrinsics
        ImportWriter.RenderIntrinsicsImport(sb);

        // ESM imports for cross-assembly dependencies
        if (dependencyTracker != null)
        {
            ImportWriter.RenderDependencyImports(sb, dependencyTracker);
        }

        // Namespaces
        foreach (var ns in assembly.Namespaces)
        {
            RenderNamespace(sb, ns);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private void RenderNamespace(StringBuilder sb, NamespaceInfo ns)
    {
        sb.AppendLine($"export declare namespace {ns.Name} {{");

        foreach (var type in ns.Types)
        {
            switch (type)
            {
                case IntersectionTypeAlias alias:
                    TypeWriter.RenderIntersectionAlias(sb, alias, 1);
                    break;
                case StaticNamespaceDeclaration staticNs:
                    TypeWriter.RenderStaticNamespace(sb, staticNs, 1);
                    break;
                case ClassDeclaration classDecl:
                    TypeWriter.RenderClass(sb, classDecl, 1);
                    break;
                case InterfaceDeclaration interfaceDecl:
                    TypeWriter.RenderInterface(sb, interfaceDecl, 1);
                    break;
                case EnumDeclaration enumDecl:
                    TypeWriter.RenderEnum(sb, enumDecl, 1);
                    break;
            }

            sb.AppendLine();
        }

        sb.AppendLine("}");
    }

}
