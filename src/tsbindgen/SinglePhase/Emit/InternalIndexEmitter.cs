using System.Text;
using tsbindgen.SinglePhase.Emit.Printers;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Model.Symbols;
using tsbindgen.SinglePhase.Plan;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits internal/index.d.ts files for each namespace.
/// Uses EmitOrder to generate declarations in deterministic order.
/// Orchestrates ClassPrinter, MethodPrinter, TypeRefPrinter.
/// </summary>
public static class InternalIndexEmitter
{
    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("InternalIndexEmitter: Generating TypeScript declarations...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log($"  Emitting namespace: {ns.Name}");

            // Generate .d.ts content
            var content = GenerateNamespaceDeclaration(ctx, nsOrder);

            // Write to file: output/Namespace.Name/internal/index.d.ts
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            var internalPath = Path.Combine(namespacePath, "internal");
            Directory.CreateDirectory(internalPath);

            var outputFile = Path.Combine(internalPath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log($"    â†’ {outputFile}");
            emittedCount++;
        }

        ctx.Log($"InternalIndexEmitter: Generated {emittedCount} declaration files");
    }

    private static string GenerateNamespaceDeclaration(BuildContext ctx, NamespaceEmitOrder nsOrder)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {nsOrder.Namespace.Name}");
        sb.AppendLine($"// Assembly: {string.Join(", ", nsOrder.Namespace.ContributingAssemblies)}");
        sb.AppendLine();

        // Branded primitive types (if this is System namespace)
        if (nsOrder.Namespace.Name == "System")
        {
            EmitBrandedPrimitives(sb);
        }

        // Namespace declaration
        sb.AppendLine($"export namespace {nsOrder.Namespace.Name} {{");

        // Emit types in order
        foreach (var typeOrder in nsOrder.OrderedTypes)
        {
            // Check if type has explicit views
            var views = Shape.ViewPlanner.GetPlannedViews(typeOrder.Type.ClrFullName);
            var hasViews = views.Count > 0 && (typeOrder.Type.Kind == Model.Symbols.TypeKind.Class || typeOrder.Type.Kind == Model.Symbols.TypeKind.Struct);

            if (hasViews)
            {
                // Emit class with $instance suffix (non-exported)
                var instanceClass = ClassPrinter.PrintInstance(typeOrder.Type, ctx);
                var indentedInstance = Indent(instanceClass, "    ");
                sb.AppendLine(indentedInstance);
                sb.AppendLine();

                // Emit companion views interface (non-exported)
                var viewsInterface = EmitCompanionViewsInterface(typeOrder.Type, views, ctx);
                var indentedViews = Indent(viewsInterface, "    ");
                sb.AppendLine(indentedViews);
                sb.AppendLine();

                // Emit intersection type alias (exported)
                var typeAlias = EmitIntersectionTypeAlias(typeOrder.Type, ctx);
                var indentedAlias = Indent(typeAlias, "    ");
                sb.AppendLine(indentedAlias);
                sb.AppendLine();
            }
            else
            {
                // Normal emission (no views)
                var typeDecl = ClassPrinter.Print(typeOrder.Type, ctx);
                var indented = Indent(typeDecl, "    ");
                sb.AppendLine(indented);
                sb.AppendLine();
            }
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitBrandedPrimitives(StringBuilder sb)
    {
        sb.AppendLine("// Branded primitive types for CLR numeric types");
        sb.AppendLine("export type sbyte = number & { __brand: \"sbyte\" };");
        sb.AppendLine("export type byte = number & { __brand: \"byte\" };");
        sb.AppendLine("export type short = number & { __brand: \"short\" };");
        sb.AppendLine("export type ushort = number & { __brand: \"ushort\" };");
        sb.AppendLine("export type int = number & { __brand: \"int\" };");
        sb.AppendLine("export type uint = number & { __brand: \"uint\" };");
        sb.AppendLine("export type long = number & { __brand: \"long\" };");
        sb.AppendLine("export type ulong = number & { __brand: \"ulong\" };");
        sb.AppendLine("export type float = number & { __brand: \"float\" };");
        sb.AppendLine("export type double = number & { __brand: \"double\" };");
        sb.AppendLine("export type decimal = number & { __brand: \"decimal\" };");
        sb.AppendLine("export type nint = number & { __brand: \"nint\" };");
        sb.AppendLine("export type nuint = number & { __brand: \"nuint\" };");
        sb.AppendLine();
    }

    private static string EmitCompanionViewsInterface(TypeSymbol type, List<Shape.ViewPlanner.ExplicitView> views, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var nsScope = new Core.Renaming.NamespaceScope
        {
            Namespace = type.Namespace,
            IsInternal = true,
            ScopeKey = $"ns:{type.Namespace}:internal"
        };
        var finalName = ctx.Renamer.GetFinalTypeName(type.StableId, nsScope);

        // Companion interface: __TypeName$views<...>
        sb.Append($"interface __{finalName}$views");

        // Generic parameters
        if (type.GenericParameters.Count > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.AppendLine(" {");

        // Emit view properties
        foreach (var view in views)
        {
            sb.Append("    readonly ");
            sb.Append(view.ViewPropertyName);
            sb.Append(": ");
            sb.Append(Printers.TypeRefPrinter.Print(view.InterfaceReference, ctx));
            sb.AppendLine(";");
        }

        sb.Append("}");

        return sb.ToString();
    }

    private static string EmitIntersectionTypeAlias(TypeSymbol type, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var nsScope = new Core.Renaming.NamespaceScope
        {
            Namespace = type.Namespace,
            IsInternal = true,
            ScopeKey = $"ns:{type.Namespace}:internal"
        };
        var finalName = ctx.Renamer.GetFinalTypeName(type.StableId, nsScope);

        // Type alias: export type TypeName<...> = TypeName$instance<...> & __TypeName$views<...>
        sb.Append("export type ");
        sb.Append(finalName);

        // Generic parameters
        if (type.GenericParameters.Count > 0)
        {
            sb.Append('<');
            var genericParams = string.Join(", ", type.GenericParameters.Select(gp => gp.Name));
            sb.Append(genericParams);
            sb.Append('>');
        }

        sb.Append(" = ");
        sb.Append(finalName);
        sb.Append("$instance");

        // Generic arguments
        if (type.GenericParameters.Count > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.Append(" & __");
        sb.Append(finalName);
        sb.Append("$views");

        // Generic arguments
        if (type.GenericParameters.Count > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.Append(";");

        return sb.ToString();
    }

    private static string Indent(string text, string indentation)
    {
        var lines = text.Split('\n').Select(line => string.IsNullOrWhiteSpace(line) ? line : indentation + line);
        return string.Join("\n", lines);
    }
}
