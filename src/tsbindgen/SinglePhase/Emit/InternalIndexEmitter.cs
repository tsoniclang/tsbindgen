using System.Collections.Immutable;
using System.Text;
using tsbindgen.SinglePhase.Emit.Printers;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Model.Symbols;
using tsbindgen.SinglePhase.Model.Symbols.MemberSymbols;
using tsbindgen.SinglePhase.Model.Types;
using tsbindgen.SinglePhase.Plan;
using tsbindgen.SinglePhase.Renaming;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits internal/index.d.ts files for each namespace.
/// Uses EmitOrder to generate declarations in deterministic order.
/// Orchestrates ClassPrinter, MethodPrinter, TypeRefPrinter.
/// </summary>
public static class InternalIndexEmitter
{
    /// <summary>
    /// Determines if a type should be emitted to .d.ts files.
    /// Only public types are emitted (EmitScope is for members, not types).
    /// </summary>
    public static bool ShouldEmit(TypeSymbol type)
    {
        return type.Accessibility == Accessibility.Public;
    }

    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("InternalIndexEmitter", "Generating TypeScript declarations...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("InternalIndexEmitter", $"  Emitting namespace: {ns.Name}");

            // Generate .d.ts content
            var content = GenerateNamespaceDeclaration(ctx, plan.Graph, plan.Imports, nsOrder);

            // Write to file: output/Namespace.Name/internal/index.d.ts (or _root for empty namespace)
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            // Use _root for empty namespace to avoid case-sensitivity collision with "Internal" namespace
            var subdirName = ns.IsRoot ? "_root" : "internal";
            var internalPath = Path.Combine(namespacePath, subdirName);
            Directory.CreateDirectory(internalPath);

            var outputFile = Path.Combine(internalPath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("InternalIndexEmitter", $"    → {outputFile}");
            emittedCount++;
        }

        ctx.Log("InternalIndexEmitter", $"Generated {emittedCount} declaration files");
    }

    private static string GenerateNamespaceDeclaration(BuildContext ctx, SymbolGraph graph, ImportPlan importPlan, NamespaceEmitOrder nsOrder)
    {
        // Create TypeNameResolver - single source of truth for type names
        // TS2693 FIX: Pass ImportPlan and current namespace for qualified name resolution
        var resolver = new TypeNameResolver(ctx, graph, importPlan, nsOrder.Namespace.Name);

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {nsOrder.Namespace.Name}");
        sb.AppendLine($"// Assembly: {string.Join(", ", nsOrder.Namespace.ContributingAssemblies)}");
        sb.AppendLine();

        // Branded primitive types (emitted in all namespaces for cross-namespace type references)
        // Every namespace needs these to reference System types (Int32 → int, etc.)
        EmitBrandedPrimitives(sb);

        // Check if namespace uses unsafe markers (pointers/byrefs) and emit support import if needed
        var needsSupportTypes = NamespaceUsesSupportTypes(nsOrder.Namespace);
        if (needsSupportTypes)
        {
            sb.AppendLine("// Import support types for unsafe CLR constructs");
            // Internal files are at Namespace/internal/index.d.ts, _support is at root level
            sb.AppendLine("import type { TSUnsafePointer, TSByRef } from \"../../_support/types\";");
            sb.AppendLine();
        }

        // Emit import statements for cross-namespace type references
        var imports = importPlan.GetImportsFor(nsOrder.Namespace.Name);
        if (imports.Count > 0)
        {
            sb.AppendLine("// Import types from other namespaces");

            // Sort imports by module specifier for stable output
            foreach (var import in imports.OrderBy(i => i.ImportPath))
            {
                // TS2693 FIX: Use namespace imports for value imports to make them accessible inside namespace blocks
                // TypeScript limitation: named value imports aren't accessible inside namespace declarations
                var valueImports = import.TypeImports.Where(ti => ti.IsValueImport).ToList();
                var typeOnlyImports = import.TypeImports.Where(ti => !ti.IsValueImport).ToList();

                // Emit namespace import for value imports (accessible inside namespace blocks)
                if (valueImports.Count > 0)
                {
                    sb.AppendLine($"import * as {import.NamespaceAlias} from \"{import.ImportPath}\";");
                }

                // Emit type-only imports (for type annotations - these work in namespaces)
                if (typeOnlyImports.Count > 0)
                {
                    var typeOnlyList = string.Join(", ", typeOnlyImports
                        .OrderBy(ti => ti.TypeName)
                        .Select(ti => ti.Alias != null ? $"{ti.TypeName} as {ti.Alias}" : ti.TypeName));

                    sb.AppendLine($"import type {{ {typeOnlyList} }} from \"{import.ImportPath}\";");
                }
            }

            sb.AppendLine(); // Blank line after imports
        }

        // ROOT NAMESPACE FIX: Types in root namespace (empty name) are emitted at module level
        // No namespace wrapper for root - types are module-level declarations
        var isRoot = nsOrder.Namespace.IsRoot;
        var indent = isRoot ? "" : "    ";

        // PHASE-1 FIX: Collect types for top-level re-export shim (TS2305/TS2315 fix)
        // Non-root namespaces need top-level re-exports so imports can use named imports
        // Store TypeSymbol to preserve generic parameter information
        var topLevelExports = new List<TypeSymbol>();

        // TS2315 FIX: Track types that had generics in CLR but were emitted without them
        // (e.g., static classes with generic static members - TypeScript doesn't support class-level generics for static-only classes)
        // This prevents convenience export aliases from referencing them with type parameters
        var typesWithoutGenerics = new HashSet<string>();

        if (!isRoot)
        {
            // Non-root: Wrap in namespace declaration
            sb.AppendLine($"export namespace {nsOrder.Namespace.Name} {{");
        }

        // Emit types in order (PUBLIC ONLY - internal types should not appear in .d.ts)
        foreach (var typeOrder in nsOrder.OrderedTypes.Where(to => ShouldEmit(to.Type)))
        {
            // Check if type has explicit views (attached by ViewPlanner)
            var views = typeOrder.Type.ExplicitViews;
            var hasViews = views.Length > 0 && (typeOrder.Type.Kind == Model.Symbols.TypeKind.Class || typeOrder.Type.Kind == Model.Symbols.TypeKind.Struct);

            if (hasViews)
            {
                // Emit class with $instance suffix - PUBLIC TYPES GET export KEYWORD
                var instanceClass = ClassPrinter.PrintInstance(typeOrder.Type, resolver, ctx, graph);
                var indentedInstance = Indent(instanceClass, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indentedInstance);
                sb.AppendLine();

                // Emit companion views interface - PUBLIC TYPES GET export KEYWORD
                var viewsInterface = EmitCompanionViewsInterface(typeOrder.Type, views, resolver, ctx);
                var indentedViews = Indent(viewsInterface, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indentedViews);
                sb.AppendLine();

                // Emit intersection type alias (already has export in the returned string)
                var typeAlias = EmitIntersectionTypeAlias(typeOrder.Type, resolver, ctx);
                var indentedAlias = Indent(typeAlias, indent);

                // Type alias already includes "export" keyword
                sb.AppendLine(indentedAlias);
                sb.AppendLine();

                // PHASE-1 FIX: Collect type for top-level re-export
                // For views pattern: export the final type alias
                if (!isRoot)
                    topLevelExports.Add(typeOrder.Type);
            }
            else
            {
                // Normal emission (no views) - PUBLIC TYPES GET export KEYWORD
                var typeDecl = ClassPrinter.Print(typeOrder.Type, resolver, ctx, graph, typesWithoutGenerics);
                var indented = Indent(typeDecl, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indented);
                sb.AppendLine();

                // PHASE-1 FIX: Collect type for top-level re-export
                if (!isRoot)
                    topLevelExports.Add(typeOrder.Type);
            }
        }

        if (!isRoot)
        {
            // Close namespace wrapper
            sb.AppendLine("}");
            sb.AppendLine();

            // PHASE-1 FIX: Emit top-level re-exports for TS2305/TS2315 fix
            // This allows: import type { Object_ } from "../../System/internal/index"
            // Instead of:  import type { System } from "../../System/internal/index"
            // Once verified working, we can remove namespace wrapper entirely (PHASE-2)
            if (topLevelExports.Count > 0)
            {
                sb.AppendLine("// Top-level re-exports (transitional shim for import compatibility)");
                sb.AppendLine($"// These allow named imports instead of namespace imports");

                // Sort by type name for stable output
                var sortedExports = topLevelExports.OrderBy(t => ctx.Renamer.GetFinalTypeName(t)).ToList();

                // INTERNAL CONSTRAINTS: Emit type aliases with generic constraints preserved
                foreach (var type in sortedExports)
                {
                    var typeName = ctx.Renamer.GetFinalTypeName(type);

                    // TS2315 FIX: Skip convenience exports for types that lost their generics during emission
                    // These are static classes with generic static members - emitted as non-generic classes
                    if (typesWithoutGenerics.Contains(typeName))
                    {
                        ctx.Log("TS2315Fix", $"Skipping convenience export for {typeName} (type was emitted without generics)");
                        continue;
                    }

                    // Use unified alias emitter with constraints
                    // Emit: export type Foo<T extends IFoo> = Namespace.Foo<T>;
                    AliasEmit.EmitGenericAlias(
                        sb,
                        aliasName: typeName,
                        sourceType: type,
                        rhsExpression: $"{nsOrder.Namespace.Name}.{typeName}",
                        resolver,
                        ctx,
                        withConstraints: true); // Internal convenience exports preserve constraints
                }
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// INTERNAL CONSTRAINTS: Generates generic type parameters WITH constraints for internal convenience exports.
    /// Mirrors the facade constraint propagation logic to fix TS2344 errors in module-level type aliases.
    /// </summary>
    private static string GenerateTypeParametersWithConstraints(
        Model.Symbols.TypeSymbol sourceType,
        TypeNameResolver resolver,
        BuildContext ctx)
    {
        var gps = sourceType.GenericParameters;
        if (gps.Length == 0)
            return string.Empty;

        var parts = new List<string>(gps.Length);

        foreach (var gp in gps)
        {
            // Collect type constraints (interfaces/classes)
            // Skip C# special constraints (struct, class, new()) as TypeScript can't express them
            var typeConstraints = gp.Constraints
                .Where(c => c is not null && !IsSpecialConstraint(c))
                .ToList();

            if (typeConstraints.Count == 0)
            {
                // No constraints: just the parameter name
                parts.Add(gp.Name);
            }
            else
            {
                // Print each constraint using TypeRefPrinter (handles CLROf, imports, etc.)
                var constraintStrings = typeConstraints
                    .Select(c => Printers.TypeRefPrinter.Print(c, resolver, ctx))
                    .ToArray();

                // Join multiple constraints with & (intersection type)
                var constraintList = string.Join(" & ", constraintStrings);
                parts.Add($"{gp.Name} extends {constraintList}");
            }
        }

        return $"<{string.Join(", ", parts)}>";
    }

    /// <summary>
    /// Check if a constraint is a C# special constraint (struct, class, new()).
    /// These don't translate to TypeScript and should be filtered out.
    /// </summary>
    private static bool IsSpecialConstraint(Model.Types.TypeReference constraint)
    {
        // Special constraints (struct, class, new()) are not in GenericParameter.Constraints
        // They're represented by separate flags in the model
        // This method is here for future-proofing in case the model changes
        return false;
    }

    private static void EmitBrandedPrimitives(StringBuilder sb)
    {
        sb.AppendLine("// Branded primitive types for CLR numeric types");

        sb.AppendLine("// Primitives implement IEquatable and IComparable to satisfy generic constraints");
        sb.AppendLine("// Note: Using 'any' in interface type parameters to avoid circular reference (TS2456)");

        // Use inline type imports to reference interfaces from System namespace
        // Format: import("relative-path").InterfaceName
        // IMPORTANT: Use 'any' as type parameter to avoid circular references
        // TypeScript limitation: `type byte = ... & IEquatable_1<byte>` causes TS2456
        const string IEq = "import(\"../../System/internal/index\").IEquatable_1<any>";
        const string ICmp = "import(\"../../System/internal/index\").IComparable_1<any>";

        // Integer types
        sb.AppendLine($"export type sbyte = number & {{ __brand: \"sbyte\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type byte = number & {{ __brand: \"byte\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type short = number & {{ __brand: \"short\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type ushort = number & {{ __brand: \"ushort\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type int = number & {{ __brand: \"int\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type uint = number & {{ __brand: \"uint\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type long = number & {{ __brand: \"long\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type ulong = number & {{ __brand: \"ulong\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type int128 = number & {{ __brand: \"int128\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type uint128 = number & {{ __brand: \"uint128\" }} & {IEq} & {ICmp};");

        // Floating-point types
        sb.AppendLine($"export type half = number & {{ __brand: \"half\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type float = number & {{ __brand: \"float\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type double = number & {{ __brand: \"double\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type decimal = number & {{ __brand: \"decimal\" }} & {IEq} & {ICmp};");

        // Native-sized integers
        sb.AppendLine($"export type nint = number & {{ __brand: \"nint\" }} & {IEq} & {ICmp};");
        sb.AppendLine($"export type nuint = number & {{ __brand: \"nuint\" }} & {IEq} & {ICmp};");

        // Character type
        sb.AppendLine($"export type char = string & {{ __brand: \"char\" }} & {IEq} & {ICmp};");

        sb.AppendLine();

        // CLROf<T> - Primitive Lifting Utility
        // CRITICAL: Uses PrimitiveLift.Rules as single source of truth (PG_GENERIC_PRIM_LIFT_001)
        sb.AppendLine("// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints");
        sb.AppendLine("// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints");
        sb.AppendLine("// Value positions (parameters, return types) use lowercase primitives for ergonomics");
        sb.AppendLine("export type CLROf<T> =");

        // Generate conditional type branches from PrimitiveLift.Rules
        foreach (var (tsName, _, clrSimpleName) in PrimitiveLift.Rules)
        {
            sb.AppendLine($"    T extends {tsName} ? import(\"../../System/internal/index\").{clrSimpleName} :");
        }

        sb.AppendLine("    T; // Identity fallback for non-primitive types");
        sb.AppendLine();
    }

    private static string EmitCompanionViewsInterface(TypeSymbol type, ImmutableArray<Shape.ViewPlanner.ExplicitView> views, TypeNameResolver resolver, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var finalName = ctx.Renamer.GetFinalTypeName(type);

        // Companion interface: __TypeName$views<...>
        sb.Append($"interface __{finalName}$views");

        // Generic parameters
        if (type.GenericParameters.Length > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.AppendLine(" {");

        // Emit view properties
        foreach (var view in views)
        {
            sb.Append("    readonly ");
            sb.Append(view.ViewPropertyName);
            sb.Append(": ");

            // FIX D: Match view's interface reference to type's actual interface implementation
            // to get correct type arguments (fixes generic "T" leaks in view interfaces)
            var matchedInterface = FindMatchingInterface(type, view.InterfaceReference);
            var interfaceToEmit = matchedInterface ?? view.InterfaceReference;

            sb.Append(Printers.TypeRefPrinter.Print(interfaceToEmit, resolver, ctx));
            sb.AppendLine(";");
        }

        sb.Append("}");

        return sb.ToString();
    }

    /// <summary>
    /// FIX D: Find the matching interface in type.Interfaces that corresponds to the view's interface reference.
    /// Returns the matched interface with correct type arguments, or null if not found.
    /// </summary>
    private static TypeReference? FindMatchingInterface(TypeSymbol type, TypeReference viewInterfaceRef)
    {
        // Get the base name without type arguments for matching
        var viewBaseName = GetInterfaceBaseName(viewInterfaceRef);

        foreach (var implementedInterface in type.Interfaces)
        {
            var implBaseName = GetInterfaceBaseName(implementedInterface);

            // Match by base name (e.g., "IEnumerator_1" matches)
            if (viewBaseName == implBaseName)
            {
                return implementedInterface;
            }
        }

        return null;
    }

    /// <summary>
    /// Get the base name of an interface (without type arguments) for matching.
    /// Examples: "IEnumerator`1" -> "IEnumerator`1", "System.Collections.Generic.IEnumerator`1" -> "IEnumerator`1"
    /// </summary>
    private static string GetInterfaceBaseName(TypeReference typeRef)
    {
        return typeRef switch
        {
            NamedTypeReference named => named.Name,  // Just the name, e.g., "IEnumerator`1"
            NestedTypeReference nested => nested.NestedName,
            _ => typeRef.ToString() ?? ""
        };
    }

    private static string EmitIntersectionTypeAlias(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var finalName = ctx.Renamer.GetFinalTypeName(type);

        // VIEW COMPOSITION CONSTRAINTS: Type alias with constraints on LHS, plain args on RHS
        // export type TypeName<T extends IFoo> = TypeName$instance<T> & __TypeName$views<T>

        // Build RHS: both $instance and $views need type arguments
        var typeArgs = AliasEmit.GenerateTypeArguments(type);
        var rhsExpression = $"{finalName}$instance{typeArgs} & __{finalName}$views{typeArgs}";

        // Emit the alias with constraints on LHS
        // Note: We pass the complete RHS (including type args), so we use the manual emission
        sb.Append("export type ");
        sb.Append(finalName);

        var typeParamsLHS = AliasEmit.GenerateTypeParametersWithConstraints(type, resolver, ctx);
        sb.Append(typeParamsLHS);

        sb.Append(" = ");
        sb.Append(rhsExpression);
        sb.AppendLine(";");

        return sb.ToString();
    }

    private static string Indent(string text, string indentation)
    {
        var lines = text.Split('\n').Select(line => string.IsNullOrWhiteSpace(line) ? line : indentation + line);
        return string.Join("\n", lines);
    }

    /// <summary>
    /// Check if namespace contains any pointer or byref types that require support type markers.
    /// Scans all public types and their members for PointerTypeReference or ByRefTypeReference.
    /// </summary>
    private static bool NamespaceUsesSupportTypes(NamespaceSymbol ns)
    {
        foreach (var type in ns.Types.Where(t => t.Accessibility == Accessibility.Public))
        {
            // TS2304 FIX: Check constructors for unsafe types
            foreach (var ctor in type.Members.Constructors)
            {
                // Constructors are always on class surface
                foreach (var param in ctor.Parameters)
                {
                    if (ContainsUnsafeType(param.Type))
                        return true;
                }
            }

            // Check methods (only those actually emitted to class/static surface)
            foreach (var method in type.Members.Methods)
            {
                // Only check methods on class/static surface (skip ViewOnly)
                if (method.EmitScope != EmitScope.ClassSurface && method.EmitScope != EmitScope.StaticSurface)
                    continue;

                // Check return type
                if (ContainsUnsafeType(method.ReturnType))
                    return true;

                // Check parameters
                foreach (var param in method.Parameters)
                {
                    if (ContainsUnsafeType(param.Type))
                        return true;
                }
            }

            // Check properties (only those on class/static surface)
            foreach (var prop in type.Members.Properties)
            {
                if (prop.EmitScope != EmitScope.ClassSurface && prop.EmitScope != EmitScope.StaticSurface)
                    continue;

                if (ContainsUnsafeType(prop.PropertyType))
                    return true;
            }

            // Check fields (only those on class/static surface)
            foreach (var field in type.Members.Fields)
            {
                if (field.EmitScope != EmitScope.ClassSurface && field.EmitScope != EmitScope.StaticSurface)
                    continue;

                if (ContainsUnsafeType(field.FieldType))
                    return true;
            }

            // Check events (only those on class/static surface)
            foreach (var evt in type.Members.Events)
            {
                if (evt.EmitScope != EmitScope.ClassSurface && evt.EmitScope != EmitScope.StaticSurface)
                    continue;

                if (ContainsUnsafeType(evt.EventHandlerType))
                    return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Recursively check if a type reference contains pointers or byrefs.
    /// </summary>
    private static bool ContainsUnsafeType(Model.Types.TypeReference typeRef)
    {
        return typeRef switch
        {
            Model.Types.PointerTypeReference => true,
            Model.Types.ByRefTypeReference => true,
            Model.Types.ArrayTypeReference arr => ContainsUnsafeType(arr.ElementType),
            Model.Types.NamedTypeReference named => named.TypeArguments.Any(ContainsUnsafeType),
            Model.Types.NestedTypeReference nested => ContainsUnsafeType(nested.FullReference),
            _ => false
        };
    }
}
