using System.Collections.Immutable;
using System.Text;
using tsbindgen.SinglePhase.Emit.Printers;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Model.Symbols;
using tsbindgen.SinglePhase.Plan;
using tsbindgen.SinglePhase.Renaming;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits internal/index.d.ts files for each namespace.
/// Uses EmitOrder to generate declarations in deterministic order.
/// Orchestrates ClassPrinter, MethodPrinter, TypeRefPrinter.
/// </summary>
public static class InternalIndexEmitter
{
    /// <summary>
    /// Determines if a type should be emitted to .d.ts files.
    /// Only public types are emitted (EmitScope is for members, not types).
    /// </summary>
    public static bool ShouldEmit(TypeSymbol type)
    {
        return type.Accessibility == Accessibility.Public;
    }

    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("InternalIndexEmitter", "Generating TypeScript declarations...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("InternalIndexEmitter", $"  Emitting namespace: {ns.Name}");

            // Generate .d.ts content
            var content = GenerateNamespaceDeclaration(ctx, plan.Graph, plan.Imports, nsOrder);

            // Write to file: output/Namespace.Name/internal/index.d.ts (or _root for empty namespace)
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            // Use _root for empty namespace to avoid case-sensitivity collision with "Internal" namespace
            var subdirName = ns.IsRoot ? "_root" : "internal";
            var internalPath = Path.Combine(namespacePath, subdirName);
            Directory.CreateDirectory(internalPath);

            var outputFile = Path.Combine(internalPath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("InternalIndexEmitter", $"    → {outputFile}");
            emittedCount++;
        }

        ctx.Log("InternalIndexEmitter", $"Generated {emittedCount} declaration files");
    }

    private static string GenerateNamespaceDeclaration(BuildContext ctx, SymbolGraph graph, ImportPlan importPlan, NamespaceEmitOrder nsOrder)
    {
        // Create TypeNameResolver - single source of truth for type names
        var resolver = new TypeNameResolver(ctx, graph);

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {nsOrder.Namespace.Name}");
        sb.AppendLine($"// Assembly: {string.Join(", ", nsOrder.Namespace.ContributingAssemblies)}");
        sb.AppendLine();

        // Branded primitive types (emitted in all namespaces for cross-namespace type references)
        // Every namespace needs these to reference System types (Int32 → int, etc.)
        EmitBrandedPrimitives(sb);

        // Emit import statements for cross-namespace type references
        var imports = importPlan.GetImportsFor(nsOrder.Namespace.Name);
        if (imports.Count > 0)
        {
            sb.AppendLine("// Import types from other namespaces");

            // Sort imports by module specifier for stable output
            foreach (var import in imports.OrderBy(i => i.ImportPath))
            {
                // Build type list with aliases if needed
                var typeImports = import.TypeImports
                    .OrderBy(ti => ti.TypeName)
                    .Select(ti => ti.Alias != null ? $"{ti.TypeName} as {ti.Alias}" : ti.TypeName);

                var typeList = string.Join(", ", typeImports);
                sb.AppendLine($"import type {{ {typeList} }} from \"{import.ImportPath}\";");
            }

            sb.AppendLine(); // Blank line after imports
        }

        // ROOT NAMESPACE FIX: Types in root namespace (empty name) are emitted at module level
        // No namespace wrapper for root - types are module-level declarations
        var isRoot = nsOrder.Namespace.IsRoot;
        var indent = isRoot ? "" : "    ";

        if (!isRoot)
        {
            // Non-root: Wrap in namespace declaration
            sb.AppendLine($"export namespace {nsOrder.Namespace.Name} {{");
        }

        // Emit types in order (PUBLIC ONLY - internal types should not appear in .d.ts)
        foreach (var typeOrder in nsOrder.OrderedTypes.Where(to => ShouldEmit(to.Type)))
        {
            // Check if type has explicit views (attached by ViewPlanner)
            var views = typeOrder.Type.ExplicitViews;
            var hasViews = views.Length > 0 && (typeOrder.Type.Kind == Model.Symbols.TypeKind.Class || typeOrder.Type.Kind == Model.Symbols.TypeKind.Struct);

            if (hasViews)
            {
                // Emit class with $instance suffix - PUBLIC TYPES GET export KEYWORD
                var instanceClass = ClassPrinter.PrintInstance(typeOrder.Type, resolver, ctx);
                var indentedInstance = Indent(instanceClass, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indentedInstance);
                sb.AppendLine();

                // Emit companion views interface - PUBLIC TYPES GET export KEYWORD
                var viewsInterface = EmitCompanionViewsInterface(typeOrder.Type, views, resolver, ctx);
                var indentedViews = Indent(viewsInterface, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indentedViews);
                sb.AppendLine();

                // Emit intersection type alias (already has export in the returned string)
                var typeAlias = EmitIntersectionTypeAlias(typeOrder.Type, resolver, ctx);
                var indentedAlias = Indent(typeAlias, indent);

                // Type alias already includes "export" keyword
                sb.AppendLine(indentedAlias);
                sb.AppendLine();
            }
            else
            {
                // Normal emission (no views) - PUBLIC TYPES GET export KEYWORD
                var typeDecl = ClassPrinter.Print(typeOrder.Type, resolver, ctx);
                var indented = Indent(typeDecl, indent);

                // PUBLIC TYPES: Always export (both root and namespaces)
                sb.Append("export ");
                sb.AppendLine(indented);
                sb.AppendLine();
            }
        }

        if (!isRoot)
        {
            // Close namespace wrapper
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void EmitBrandedPrimitives(StringBuilder sb)
    {
        sb.AppendLine("// Branded primitive types for CLR numeric types");
        sb.AppendLine("export type sbyte = number & { __brand: \"sbyte\" };");
        sb.AppendLine("export type byte = number & { __brand: \"byte\" };");
        sb.AppendLine("export type short = number & { __brand: \"short\" };");
        sb.AppendLine("export type ushort = number & { __brand: \"ushort\" };");
        sb.AppendLine("export type int = number & { __brand: \"int\" };");
        sb.AppendLine("export type uint = number & { __brand: \"uint\" };");
        sb.AppendLine("export type long = number & { __brand: \"long\" };");
        sb.AppendLine("export type ulong = number & { __brand: \"ulong\" };");
        sb.AppendLine("export type float = number & { __brand: \"float\" };");
        sb.AppendLine("export type double = number & { __brand: \"double\" };");
        sb.AppendLine("export type decimal = number & { __brand: \"decimal\" };");
        sb.AppendLine("export type nint = number & { __brand: \"nint\" };");
        sb.AppendLine("export type nuint = number & { __brand: \"nuint\" };");
        sb.AppendLine();
    }

    private static string EmitCompanionViewsInterface(TypeSymbol type, ImmutableArray<Shape.ViewPlanner.ExplicitView> views, TypeNameResolver resolver, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var finalName = ctx.Renamer.GetFinalTypeName(type);

        // Companion interface: __TypeName$views<...>
        sb.Append($"interface __{finalName}$views");

        // Generic parameters
        if (type.GenericParameters.Length > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.AppendLine(" {");

        // Emit view properties
        foreach (var view in views)
        {
            sb.Append("    readonly ");
            sb.Append(view.ViewPropertyName);
            sb.Append(": ");
            sb.Append(Printers.TypeRefPrinter.Print(view.InterfaceReference, resolver, ctx));
            sb.AppendLine(";");
        }

        sb.Append("}");

        return sb.ToString();
    }

    private static string EmitIntersectionTypeAlias(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
    {
        var sb = new StringBuilder();

        // Get final type name
        var finalName = ctx.Renamer.GetFinalTypeName(type);

        // Type alias: export type TypeName<...> = TypeName$instance<...> & __TypeName$views<...>
        sb.Append("export type ");
        sb.Append(finalName);

        // Generic parameters
        if (type.GenericParameters.Length > 0)
        {
            sb.Append('<');
            var genericParams = string.Join(", ", type.GenericParameters.Select(gp => gp.Name));
            sb.Append(genericParams);
            sb.Append('>');
        }

        sb.Append(" = ");
        sb.Append(finalName);
        sb.Append("$instance");

        // Generic arguments
        if (type.GenericParameters.Length > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.Append(" & __");
        sb.Append(finalName);
        sb.Append("$views");

        // Generic arguments
        if (type.GenericParameters.Length > 0)
        {
            sb.Append('<');
            sb.Append(string.Join(", ", type.GenericParameters.Select(gp => gp.Name)));
            sb.Append('>');
        }

        sb.Append(";");

        return sb.ToString();
    }

    private static string Indent(string text, string indentation)
    {
        var lines = text.Split('\n').Select(line => string.IsNullOrWhiteSpace(line) ? line : indentation + line);
        return string.Join("\n", lines);
    }
}
