using System.IO;
using System.Linq;
using System.Text;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Plan;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits facade/index.d.ts files for each namespace.
/// Generates public-facing TypeScript declarations with proper imports and re-exports.
/// </summary>
public static class FacadeEmitter
{
    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("FacadeEmitter", "Generating facade index.d.ts files...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("FacadeEmitter", $"  Emitting facade for: {ns.Name}");

            // Generate facade content
            var content = GenerateFacade(ctx, plan, ns);

            // Write to file: output/Namespace.Name/index.d.ts
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            Directory.CreateDirectory(namespacePath);

            var outputFile = Path.Combine(namespacePath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("FacadeEmitter", $"    â†’ {outputFile}");
            emittedCount++;
        }

        ctx.Log("FacadeEmitter", $"Generated {emittedCount} facade files");
    }

    private static string GenerateFacade(BuildContext ctx, EmissionPlan plan, Model.Symbols.NamespaceSymbol ns)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {ns.Name}");
        sb.AppendLine($"// Facade - Public API Surface");
        sb.AppendLine();

        // Import from internal/index.d.ts (or _root/index.d.ts for empty namespace)
        sb.AppendLine("// Import internal declarations");
        var subdirName = ns.IsRoot ? "_root" : "internal";
        sb.AppendLine($"import * as Internal from './{subdirName}/index';");
        sb.AppendLine();

        // Import from dependencies (if any)
        if (plan.Imports.NamespaceImports.TryGetValue(ns.Name, out var imports))
        {
            if (imports.Count > 0)
            {
                sb.AppendLine("// Import dependencies");
                foreach (var import in imports)
                {
                    sb.AppendLine($"import * as {GetImportAlias(import.TargetNamespace)} from '{import.ImportPath}';");
                }
                sb.AppendLine();
            }
        }

        // ROOT NAMESPACE FIX: Re-export internal namespace
        // For root namespace (empty name), use direct re-export instead of import alias
        // For non-root, skip dotted namespaces as TypeScript doesn't support dots in export import identifiers
        if (ns.IsRoot)
        {
            sb.AppendLine("// Re-export root namespace types (module-level)");
            sb.AppendLine($"export * from './{subdirName}/index';");
            sb.AppendLine();
        }
        else if (!ns.Name.Contains('.'))
        {
            sb.AppendLine("// Re-export namespace");
            sb.AppendLine($"export import {ns.Name} = Internal.{ns.Name};");
            sb.AppendLine();
        }

        // Export individual types (for convenience)
        if (plan.Imports.NamespaceExports.TryGetValue(ns.Name, out var exports))
        {
            if (exports.Count > 0)
            {
                sb.AppendLine("// Individual type exports for convenience");
                foreach (var export in exports)
                {
                    var exportKind = export.ExportKind switch
                    {
                        ExportKind.Class => "class",
                        ExportKind.Interface => "interface",
                        ExportKind.Enum => "enum",
                        ExportKind.Type => "type",
                        ExportKind.Const => "const",
                        _ => "type"
                    };

                    // Export types by referencing Internal namespace
                    // CRITICAL: Always use Internal.{ns.Name}.{export.ExportName} for non-root
                    // This ensures we're referencing the actual location in internal/index.d.ts
                    if (ns.IsRoot)
                    {
                        sb.AppendLine($"export type {export.ExportName} = Internal.{export.ExportName};");
                    }
                    else
                    {
                        sb.AppendLine($"export type {export.ExportName} = Internal.{ns.Name}.{export.ExportName};");
                    }
                }
            }
        }

        return sb.ToString();
    }

    private static string GetImportAlias(string namespaceName)
    {
        // Convert "System.Collections.Generic" to "System_Collections_Generic"
        return namespaceName.Replace('.', '_');
    }
}
