using System.IO;
using System.Linq;
using System.Text;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Plan;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits facade/index.d.ts files for each namespace.
/// Generates public-facing TypeScript declarations with proper imports and re-exports.
/// </summary>
public static class FacadeEmitter
{
    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("FacadeEmitter", "Generating facade index.d.ts files...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("FacadeEmitter", $"  Emitting facade for: {ns.Name}");

            // Generate facade content
            var content = GenerateFacade(ctx, plan, ns);

            // Write to file: output/Namespace.Name/index.d.ts
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            Directory.CreateDirectory(namespacePath);

            var outputFile = Path.Combine(namespacePath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("FacadeEmitter", $"    â†’ {outputFile}");
            emittedCount++;
        }

        ctx.Log("FacadeEmitter", $"Generated {emittedCount} facade files");
    }

    private static string GenerateFacade(BuildContext ctx, EmissionPlan plan, Model.Symbols.NamespaceSymbol ns)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {ns.Name}");
        sb.AppendLine($"// Facade - Public API Surface");
        sb.AppendLine();

        // Import from internal/index.d.ts (or _root/index.d.ts for empty namespace)
        sb.AppendLine("// Import internal declarations");
        var subdirName = ns.IsRoot ? "_root" : "internal";
        sb.AppendLine($"import * as Internal from './{subdirName}/index';");
        sb.AppendLine();

        // Import from dependencies (if any)
        if (plan.Imports.NamespaceImports.TryGetValue(ns.Name, out var imports))
        {
            if (imports.Count > 0)
            {
                sb.AppendLine("// Import dependencies");
                foreach (var import in imports)
                {
                    // Facade files are one level shallower than internal files
                    // Internal: Namespace/internal/index.d.ts uses ../../Target/internal/index
                    // Facade: Namespace/index.d.ts needs ../Target/internal/index
                    var facadePath = AdjustPathForFacade(import.ImportPath);
                    sb.AppendLine($"import * as {GetImportAlias(import.TargetNamespace)} from '{facadePath}';");
                }
                sb.AppendLine();
            }
        }

        // ROOT NAMESPACE FIX: Re-export internal namespace
        // For root namespace (empty name), use direct re-export instead of import alias
        // For non-root, skip dotted namespaces as TypeScript doesn't support dots in export import identifiers
        if (ns.IsRoot)
        {
            sb.AppendLine("// Re-export root namespace types (module-level)");
            sb.AppendLine($"export * from './{subdirName}/index';");
            sb.AppendLine();
        }
        else if (!ns.Name.Contains('.'))
        {
            sb.AppendLine("// Re-export namespace");
            sb.AppendLine($"export import {ns.Name} = Internal.{ns.Name};");
            sb.AppendLine();
        }

        // Export individual types (for convenience)
        if (plan.Imports.NamespaceExports.TryGetValue(ns.Name, out var exports))
        {
            if (exports.Count > 0)
            {
                sb.AppendLine("// Individual type exports for convenience");

                // Create TypeNameResolver for constraint printing
                var resolver = new TypeNameResolver(ctx, plan.Graph);

                foreach (var export in exports)
                {
                    var exportKind = export.ExportKind switch
                    {
                        ExportKind.Class => "class",
                        ExportKind.Interface => "interface",
                        ExportKind.Enum => "enum",
                        ExportKind.Type => "type",
                        ExportKind.Const => "const",
                        _ => "type"
                    };

                    // TS2315 FIX: Skip facade exports for types that lose their generics during emission
                    // Static classes with generic static members are emitted as non-generic classes
                    // (TypeScript doesn't support class-level generics for static-only classes)
                    if (export.SourceType.Kind == Model.Symbols.TypeKind.StaticNamespace &&
                        export.SourceType.GenericParameters.Length > 0)
                    {
                        ctx.Log("TS2315Fix", $"Skipping facade export for {export.ExportName} (static class with generics - emitted without generic parameters)");
                        continue;
                    }

                    // FACADE CONSTRAINTS: Use unified alias emitter with constraints
                    // Export types by referencing Internal namespace
                    // CRITICAL: Always use Internal.{ns.Name}.{export.ExportName} for non-root
                    // This ensures we're referencing the actual location in internal/index.d.ts
                    var rhsBase = ns.IsRoot
                        ? $"Internal.{export.ExportName}"
                        : $"Internal.{ns.Name}.{export.ExportName}";

                    AliasEmit.EmitGenericAlias(
                        sb,
                        aliasName: export.ExportName,
                        sourceType: export.SourceType,
                        rhsExpression: rhsBase,
                        resolver,
                        ctx,
                        withConstraints: true); // Facade preserves constraints
                }
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// Adjusts import path for facade files (one directory level shallower than internal files).
    /// Converts "../../Target/internal/index" to "../Target/internal/index"
    /// </summary>
    private static string AdjustPathForFacade(string internalPath)
    {
        // Internal files are at: Namespace/internal/index.d.ts
        // Facade files are at: Namespace/index.d.ts
        // So facade files need one less "../" in relative paths

        if (internalPath.StartsWith("../../"))
        {
            // Strip one "../" from the beginning
            return "../" + internalPath.Substring(6); // Remove "../../", keep rest
        }

        // For paths that don't start with "../../" (shouldn't happen, but defensive)
        return internalPath;
    }

    private static string GetImportAlias(string namespaceName)
    {
        // Convert "System.Collections.Generic" to "System_Collections_Generic"
        return namespaceName.Replace('.', '_');
    }

    /// <summary>
    /// FACADE CONSTRAINTS: Generates generic type parameters WITH constraints for facade type aliases.
    /// Mirrors source type's generic parameter constraints to maintain type safety across facade boundary.
    ///
    /// Examples:
    ///   No constraints: "<T>" or "<T1, T2>"
    ///   With constraints: "<T extends IEquatable_1<T>>"
    ///   Multiple constraints: "<T extends IComparable_1<T> & IEquatable_1<T>>"
    ///   Mixed: "<T, U extends IComparer_1<T>>"
    ///
    /// CLROf wrapping is automatically applied by TypeRefPrinter for primitive type arguments in constraints.
    /// </summary>
    private static string GenerateTypeParametersWithConstraints(
        Model.Symbols.TypeSymbol sourceType,
        TypeNameResolver resolver,
        BuildContext ctx)
    {
        var gps = sourceType.GenericParameters;
        if (gps.Length == 0)
            return string.Empty;

        var parts = new List<string>(gps.Length);

        foreach (var gp in gps)
        {
            // Collect type constraints (interfaces/classes)
            // Skip C# special constraints (struct, class, new()) as TypeScript can't express them
            var typeConstraints = gp.Constraints
                .Where(c => c is not null && !IsSpecialConstraint(c))
                .ToList();

            if (typeConstraints.Count == 0)
            {
                // No constraints: just the parameter name
                parts.Add(gp.Name);
            }
            else
            {
                // Print each constraint using TypeRefPrinter (handles CLROf, imports, etc.)
                var constraintStrings = typeConstraints
                    .Select(c => Printers.TypeRefPrinter.Print(c, resolver, ctx))
                    .ToArray();

                // Join multiple constraints with & (intersection type)
                var constraintList = string.Join(" & ", constraintStrings);
                parts.Add($"{gp.Name} extends {constraintList}");
            }
        }

        return $"<{string.Join(", ", parts)}>";
    }

    /// <summary>
    /// Check if a constraint is a C# special constraint (struct, class, new()).
    /// These don't translate to TypeScript and should be filtered out.
    ///
    /// In current model, special constraints are NOT represented as TypeReferences in Constraints array,
    /// so this is a defensive check that always returns false.
    /// </summary>
    private static bool IsSpecialConstraint(Model.Types.TypeReference constraint)
    {
        // Special constraints (struct, class, new()) are not in GenericParameter.Constraints
        // They're represented by separate flags in the model
        // This method is here for future-proofing in case the model changes
        return false;
    }

    /// <summary>
    /// Generates simple type argument list for RHS of facade alias (no constraints).
    /// Uses actual generic parameter names from source type for consistency.
    /// Examples: "<T>", "<TKey, TValue>", "<T1, T2, T3>"
    /// </summary>
    private static string GenerateTypeArguments(Model.Symbols.TypeSymbol sourceType)
    {
        var gps = sourceType.GenericParameters;
        if (gps.Length == 0)
            return string.Empty;

        var names = gps.Select(gp => gp.Name);
        return $"<{string.Join(", ", names)}>";
    }

    /// <summary>
    /// DEPRECATED: Old arity-based parameter generator.
    /// Use GenerateTypeParametersWithConstraints instead to preserve type safety.
    /// Kept for reference during migration.
    /// </summary>
    private static string GenerateTypeParameters(int arity)
    {
        if (arity == 0)
            return string.Empty;

        if (arity == 1)
            return "<T>";

        // For arity > 1, use T1, T2, T3, ...
        var typeParams = string.Join(", ", Enumerable.Range(1, arity).Select(i => $"T{i}"));
        return $"<{typeParams}>";
    }
}
