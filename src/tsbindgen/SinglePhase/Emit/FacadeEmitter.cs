using System.IO;
using System.Linq;
using System.Text;
using tsbindgen.SinglePhase.Model;
using tsbindgen.SinglePhase.Plan;

namespace tsbindgen.SinglePhase.Emit;

/// <summary>
/// Emits facade/index.d.ts files for each namespace.
/// Generates public-facing TypeScript declarations with proper imports and re-exports.
/// </summary>
public static class FacadeEmitter
{
    public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
    {
        ctx.Log("FacadeEmitter", "Generating facade index.d.ts files...");

        var emittedCount = 0;

        // Process each namespace in order
        foreach (var nsOrder in plan.EmissionOrder.Namespaces)
        {
            var ns = nsOrder.Namespace;
            ctx.Log("FacadeEmitter", $"  Emitting facade for: {ns.Name}");

            // Generate facade content
            var content = GenerateFacade(ctx, plan, ns);

            // Write to file: output/Namespace.Name/index.d.ts
            var namespacePath = Path.Combine(outputDirectory, ns.Name);
            Directory.CreateDirectory(namespacePath);

            var outputFile = Path.Combine(namespacePath, "index.d.ts");
            File.WriteAllText(outputFile, content);

            ctx.Log("FacadeEmitter", $"    → {outputFile}");
            emittedCount++;
        }

        ctx.Log("FacadeEmitter", $"Generated {emittedCount} facade files");
    }

    private static string GenerateFacade(BuildContext ctx, EmissionPlan plan, Model.Symbols.NamespaceSymbol ns)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Generated by tsbindgen - Single-Phase Architecture");
        sb.AppendLine($"// Namespace: {ns.Name}");
        sb.AppendLine($"// Facade - Public API Surface");
        sb.AppendLine();

        // Import from internal/index.d.ts (or _root/index.d.ts for empty namespace)
        sb.AppendLine("// Import internal declarations");
        var subdirName = ns.IsRoot ? "_root" : "internal";
        sb.AppendLine($"import * as Internal from './{subdirName}/index';");
        sb.AppendLine();

        // Import from dependencies (if any)
        if (plan.Imports.NamespaceImports.TryGetValue(ns.Name, out var imports))
        {
            if (imports.Count > 0)
            {
                sb.AppendLine("// Import dependencies");
                foreach (var import in imports)
                {
                    // Facade files are one level shallower than internal files
                    // Internal: Namespace/internal/index.d.ts uses ../../Target/internal/index
                    // Facade: Namespace/index.d.ts needs ../Target/internal/index
                    var facadePath = AdjustPathForFacade(import.ImportPath);
                    sb.AppendLine($"import * as {GetImportAlias(import.TargetNamespace)} from '{facadePath}';");
                }
                sb.AppendLine();
            }
        }

        // ROOT NAMESPACE FIX: Re-export internal namespace
        // For root namespace (empty name), use direct re-export instead of import alias
        // For non-root, skip dotted namespaces as TypeScript doesn't support dots in export import identifiers
        if (ns.IsRoot)
        {
            sb.AppendLine("// Re-export root namespace types (module-level)");
            sb.AppendLine($"export * from './{subdirName}/index';");
            sb.AppendLine();
        }
        else if (!ns.Name.Contains('.'))
        {
            sb.AppendLine("// Re-export namespace");
            sb.AppendLine($"export import {ns.Name} = Internal.{ns.Name};");
            sb.AppendLine();
        }

        // Export individual types (for convenience)
        if (plan.Imports.NamespaceExports.TryGetValue(ns.Name, out var exports))
        {
            if (exports.Count > 0)
            {
                sb.AppendLine("// Individual type exports for convenience");
                foreach (var export in exports)
                {
                    var exportKind = export.ExportKind switch
                    {
                        ExportKind.Class => "class",
                        ExportKind.Interface => "interface",
                        ExportKind.Enum => "enum",
                        ExportKind.Type => "type",
                        ExportKind.Const => "const",
                        _ => "type"
                    };

                    // TS2314 FIX: Generate generic type parameters
                    var typeParams = GenerateTypeParameters(export.Arity);

                    // Export types by referencing Internal namespace
                    // CRITICAL: Always use Internal.{ns.Name}.{export.ExportName} for non-root
                    // This ensures we're referencing the actual location in internal/index.d.ts
                    if (ns.IsRoot)
                    {
                        sb.AppendLine($"export type {export.ExportName}{typeParams} = Internal.{export.ExportName}{typeParams};");
                    }
                    else
                    {
                        sb.AppendLine($"export type {export.ExportName}{typeParams} = Internal.{ns.Name}.{export.ExportName}{typeParams};");
                    }
                }
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// Adjusts import path for facade files (one directory level shallower than internal files).
    /// Converts "../../Target/internal/index" to "../Target/internal/index"
    /// </summary>
    private static string AdjustPathForFacade(string internalPath)
    {
        // Internal files are at: Namespace/internal/index.d.ts
        // Facade files are at: Namespace/index.d.ts
        // So facade files need one less "../" in relative paths

        if (internalPath.StartsWith("../../"))
        {
            // Strip one "../" from the beginning
            return "../" + internalPath.Substring(6); // Remove "../../", keep rest
        }

        // For paths that don't start with "../../" (shouldn't happen, but defensive)
        return internalPath;
    }

    private static string GetImportAlias(string namespaceName)
    {
        // Convert "System.Collections.Generic" to "System_Collections_Generic"
        return namespaceName.Replace('.', '_');
    }

    /// <summary>
    /// TS2314 FIX: Generates generic type parameter list for facade type aliases.
    /// Examples:
    ///   arity=0 → "" (non-generic)
    ///   arity=1 → "<T>"
    ///   arity=2 → "<T1, T2>"
    ///   arity=3 → "<T1, T2, T3>"
    /// </summary>
    private static string GenerateTypeParameters(int arity)
    {
        if (arity == 0)
            return string.Empty;

        if (arity == 1)
            return "<T>";

        // For arity > 1, use T1, T2, T3, ...
        var typeParams = string.Join(", ", Enumerable.Range(1, arity).Select(i => $"T{i}"));
        return $"<{typeParams}>";
    }
}
