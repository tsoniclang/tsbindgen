# Phase 4: Emit - Output File Generation

## Overview

The **Emit Phase** is the fourth and final phase of the single-phase architecture. It takes the validated `EmissionPlan` (from the Plan phase) and generates all output files:

1. **TypeScript Declarations** - Public-facing `.d.ts` files with TypeScript type definitions
2. **Internal Declarations** - Internal implementation `.d.ts` files with actual type definitions
3. **Metadata Sidecars** - `metadata.json` files with CLR-specific information for Tsonic compiler
4. **Binding Metadata** - `bindings.json` files mapping TypeScript names to CLR names
5. **Module Stubs** - `index.js` stub files that throw at runtime (prevent execution)
6. **Support Types** - Centralized `_support/types.d.ts` with marker types for unsafe constructs

**Key Principles:**
- **Uses Renamer for all names** - Single source of truth for TypeScript identifiers
- **Respects EmitScope** - Only emits members with ClassSurface/StaticSurface/ViewOnly scopes
- **Type safety via TypeNameResolver** - Never uses CLR names directly
- **Deterministic output** - Uses EmitOrder from Plan phase for stable ordering

---

## File Organization

### Output Directory Structure

```
output/
  System/
    index.d.ts              # Public facade (re-exports from internal/)
    index.js                # Runtime stub (throws)
    bindings.json           # CLR name mappings
    internal/
      index.d.ts            # Actual type declarations
      metadata.json         # CLR-specific metadata
  System.Collections.Generic/
    index.d.ts
    index.js
    bindings.json
    internal/
      index.d.ts
      metadata.json
  _support/
    types.d.ts              # Shared marker types (TSUnsafePointer, TSByRef)
```

**Special Cases:**
- **Root namespace** (empty name): Uses `_root/` instead of `internal/` to avoid collision with "Internal" namespace
- **Dotted namespaces**: Cannot use `export import` syntax (TypeScript limitation)

---

## File: FacadeEmitter.cs

### Purpose
Generates public-facing `index.d.ts` files for each namespace. These are the entry points that users import from.

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces` in deterministic order
- For each namespace, generates facade content via `GenerateFacade()`
- Writes to `output/{namespace}/index.d.ts`
- Logs each emitted file

**Output structure:**
- File header with generation info
- Import from `internal/index.d.ts` (or `_root/index.d.ts` for root namespace)
- Imports from dependencies (other namespaces)
- Re-export namespace (for non-dotted namespaces)
- Individual type exports for convenience

### Method: GenerateFacade()
```csharp
private static string GenerateFacade(BuildContext ctx, EmissionPlan plan, Model.Symbols.NamespaceSymbol ns)
```
**What it does:**
1. **File header** - Comments with namespace name and purpose
2. **Internal import** - `import * as Internal from './internal/index';`
3. **Dependency imports** - Cross-namespace references with aliases
4. **Namespace re-export** - `export import System = Internal.System;` (non-dotted only)
5. **Individual type exports** - `export type List_1 = Internal.System.Collections.Generic.List_1;`

**Algorithm:**
- Uses `plan.Imports.NamespaceImports` to get required imports
- Uses `plan.Imports.NamespaceExports` to get types to re-export
- Handles root namespace specially (no namespace wrapper, direct re-export)
- Skips dotted namespaces for `export import` (TypeScript doesn't support dots in identifiers)

### Method: GetImportAlias()
```csharp
private static string GetImportAlias(string namespaceName)
```
**What it does:**
- Converts dotted namespace to valid identifier: `"System.Collections.Generic"` → `"System_Collections_Generic"`

### Output Format Example

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Facade - Public API Surface

// Import internal declarations
import * as Internal from './internal/index';

// Import dependencies
import * as System from '../System/index';

// Re-export namespace
export import Generic = Internal.System.Collections.Generic;

// Individual type exports for convenience
export type List_1 = Internal.System.Collections.Generic.List_1;
export type Dictionary_2 = Internal.System.Collections.Generic.Dictionary_2;
```

---

## File: InternalIndexEmitter.cs

### Purpose
Generates `internal/index.d.ts` files with actual TypeScript declarations. These contain the real type definitions that the facade re-exports.

### Method: ShouldEmit()
```csharp
public static bool ShouldEmit(TypeSymbol type)
```
**What it does:**
- Returns `true` only for public types (`type.Accessibility == Accessibility.Public`)
- Internal types are never emitted to `.d.ts` files

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates declarations via `GenerateNamespaceDeclaration()`
- Writes to `output/{namespace}/internal/index.d.ts` (or `_root/index.d.ts` for root)
- Creates subdirectory if needed

### Method: GenerateNamespaceDeclaration()
```csharp
private static string GenerateNamespaceDeclaration(BuildContext ctx, SymbolGraph graph, ImportPlan importPlan, NamespaceEmitOrder nsOrder)
```
**What it does:**
1. **Creates TypeNameResolver** - Single source of truth for type names
2. **File header** - Comments with namespace and contributing assemblies
3. **Emits branded primitives** - All namespaces get `type int = number & { __brand: "int" };` etc.
4. **Conditional support types import** - If namespace uses pointers/byrefs, imports from `_support/types.d.ts`
5. **Cross-namespace imports** - Type imports from other namespaces with aliases if needed
6. **Namespace wrapper** - `export namespace Foo {` (skipped for root namespace)
7. **Type declarations** - Iterates through `nsOrder.OrderedTypes` and emits each

**Algorithm:**
- Calls `NamespaceUsesSupportTypes()` to check if `TSUnsafePointer`/`TSByRef` needed
- Uses `importPlan.GetImportsFor()` to get cross-namespace imports
- For root namespace, emits types at module level (no namespace wrapper)
- For each type, checks if it has explicit views (companion views pattern):
  - **With views**: Emits `TypeName$instance` class + `__TypeName$views` interface + intersection type alias
  - **Without views**: Emits normal class/interface/enum/delegate

### Method: EmitBrandedPrimitives()
```csharp
private static void EmitBrandedPrimitives(StringBuilder sb)
```
**What it does:**
- Emits branded primitive type aliases for all CLR numeric types:
  - `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`
  - `float`, `double`, `decimal`, `nint`, `nuint`

### Method: EmitCompanionViewsInterface()
```csharp
private static string EmitCompanionViewsInterface(TypeSymbol type, ImmutableArray<Shape.ViewPlanner.ExplicitView> views, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Generates companion interface with view properties: `interface __List_1$views<T> { ... }`
- Each view becomes a readonly property: `readonly IEnumerable_1$view: IEnumerable_1<T>;`

### Method: EmitIntersectionTypeAlias()
```csharp
private static string EmitIntersectionTypeAlias(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Creates type alias that intersects instance and views:
  - `export type List_1<T> = List_1$instance<T> & __List_1$views<T>;`

### Method: NamespaceUsesSupportTypes()
```csharp
private static bool NamespaceUsesSupportTypes(NamespaceSymbol ns)
```
**What it does:**
- Scans all public types and their ClassSurface/StaticSurface members
- Checks if any use `PointerTypeReference` or `ByRefTypeReference`
- Returns `true` if support types import needed

### Method: ContainsUnsafeType()
```csharp
private static bool ContainsUnsafeType(Model.Types.TypeReference typeRef)
```
**What it does:**
- Recursively checks type reference for pointers/byrefs
- Handles arrays (checks element type), named types (checks type arguments), nested types

### Output Format Example

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Private.CoreLib

// Branded primitive types for CLR numeric types
export type sbyte = number & { __brand: "sbyte" };
export type byte = number & { __brand: "byte" };
export type int = number & { __brand: "int" };
// ... all primitives ...

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../_support/types";

// Import types from other namespaces
import type { Object, ValueType } from "../System/internal/index";

export namespace System.Collections.Generic {
    // With companion views:
    export class List_1$instance<T> {
        constructor(capacity: int);
        readonly Count: int;
        Add(item: T): void;
    }

    export interface __List_1$views<T> {
        readonly IEnumerable_1$view: IEnumerable_1<T>;
    }

    export type List_1<T> = List_1$instance<T> & __List_1$views<T>;

    // Without views:
    export interface IEnumerable_1<T> {
        GetEnumerator(): IEnumerator_1<T>;
    }
}
```

---

## File: MetadataEmitter.cs

### Purpose
Generates `metadata.json` files with CLR-specific information that TypeScript can't represent. Used by Tsonic compiler for correct C# code generation.

### Record: NamespaceMetadata
```csharp
public sealed record NamespaceMetadata
{
    public required string Namespace { get; init; }
    public required List<string> ContributingAssemblies { get; init; }
    public required List<TypeMetadata> Types { get; init; }
}
```

### Record: TypeMetadata
```csharp
public sealed record TypeMetadata
{
    public required string ClrName { get; init; }           // "System.Collections.Generic.List`1"
    public required string TsEmitName { get; init; }        // "List_1"
    public required string Kind { get; init; }              // "Class"
    public required string Accessibility { get; init; }      // "Public"
    public required bool IsAbstract { get; init; }
    public required bool IsSealed { get; init; }
    public required bool IsStatic { get; init; }
    public required int Arity { get; init; }
    public required List<MethodMetadata> Methods { get; init; }
    public required List<PropertyMetadata> Properties { get; init; }
    public required List<FieldMetadata> Fields { get; init; }
    public required List<EventMetadata> Events { get; init; }
    public required List<ConstructorMetadata> Constructors { get; init; }
}
```

### Record: MethodMetadata
```csharp
public sealed record MethodMetadata
{
    public required string ClrName { get; init; }                  // "Add"
    public required string TsEmitName { get; init; }               // "Add" or "IEnumerable_1$view$Add"
    public required string NormalizedSignature { get; init; }       // For universal matching
    public required string Provenance { get; init; }               // "Direct", "Inherited", "ExplicitImpl"
    public required string EmitScope { get; init; }                // "ClassSurface", "ViewOnly"
    public required bool IsStatic { get; init; }
    public required bool IsAbstract { get; init; }
    public required bool IsVirtual { get; init; }
    public required bool IsOverride { get; init; }
    public required bool IsSealed { get; init; }
    public required int Arity { get; init; }
    public required int ParameterCount { get; init; }
    public string? SourceInterface { get; init; }                  // For ViewOnly members
}
```

### Record: PropertyMetadata
```csharp
public sealed record PropertyMetadata
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required string NormalizedSignature { get; init; }
    public required string Provenance { get; init; }
    public required string EmitScope { get; init; }
    public required bool IsStatic { get; init; }
    public required bool IsAbstract { get; init; }
    public required bool IsVirtual { get; init; }
    public required bool IsOverride { get; init; }
    public required bool IsIndexer { get; init; }
    public required bool HasGetter { get; init; }
    public required bool HasSetter { get; init; }
    public string? SourceInterface { get; init; }
}
```

### Record: FieldMetadata
```csharp
public sealed record FieldMetadata
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required bool IsReadOnly { get; init; }
    public required bool IsLiteral { get; init; }              // const field
}
```

### Record: EventMetadata
```csharp
public sealed record EventMetadata
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
}
```

### Record: ConstructorMetadata
```csharp
public sealed record ConstructorMetadata
{
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required int ParameterCount { get; init; }
}
```

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates metadata via `GenerateMetadata()`
- Writes to `output/{namespace}/internal/metadata.json`
- Uses indented JSON format with null value omission

### Method: GenerateMetadata()
```csharp
private static NamespaceMetadata GenerateMetadata(BuildContext ctx, NamespaceEmitOrder nsOrder)
```
**What it does:**
- Creates `NamespaceMetadata` with namespace name and contributing assemblies
- For each type in `nsOrder.OrderedTypes`, calls `GenerateTypeMetadata()`

### Method: GenerateTypeMetadata()
```csharp
private static TypeMetadata GenerateTypeMetadata(TypeSymbol type, BuildContext ctx)
```
**What it does:**
- Gets final TypeScript name from `ctx.Renamer.GetFinalTypeName(type)`
- Creates `TypeMetadata` with all type information
- Generates metadata for all member kinds (methods, properties, fields, events, constructors)

### Method: GenerateMethodMetadata()
```csharp
private static MethodMetadata GenerateMethodMetadata(MethodSymbol method, TypeSymbol declaringType, BuildContext ctx)
```
**What it does:**
- Uses **view scope** for ViewOnly members (via `ScopeFactory.ViewSurface()`)
- Uses **class scope** for ClassSurface members (via `ScopeFactory.ClassSurface()`)
- Gets final TS name from `ctx.Renamer.GetFinalMemberName()`
- Generates normalized signature via `SignatureNormalization.NormalizeMethod()`

**Key Decision:**
- ViewOnly members get view-scoped names: `"IEnumerable_1$view$GetEnumerator"`
- ClassSurface members get class-scoped names: `"GetEnumerator"`

### Output Format Example

```json
{
  "Namespace": "System.Collections.Generic",
  "ContributingAssemblies": [
    "System.Private.CoreLib"
  ],
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "Kind": "Class",
      "Accessibility": "Public",
      "IsAbstract": false,
      "IsSealed": false,
      "IsStatic": false,
      "Arity": 1,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "NormalizedSignature": "Add(T):System.Void",
          "Provenance": "Direct",
          "EmitScope": "ClassSurface",
          "IsStatic": false,
          "IsAbstract": false,
          "IsVirtual": false,
          "IsOverride": false,
          "IsSealed": false,
          "Arity": 0,
          "ParameterCount": 1
        },
        {
          "ClrName": "GetEnumerator",
          "TsEmitName": "IEnumerable_1$view$GetEnumerator",
          "NormalizedSignature": "GetEnumerator():System.Collections.Generic.IEnumerator`1<T>",
          "Provenance": "ExplicitImpl",
          "EmitScope": "ViewOnly",
          "IsStatic": false,
          "IsAbstract": false,
          "IsVirtual": false,
          "IsOverride": false,
          "IsSealed": false,
          "Arity": 0,
          "ParameterCount": 0,
          "SourceInterface": "System.Collections.Generic.IEnumerable`1"
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": [
        {
          "NormalizedSignature": ".ctor(System.Int32):System.Void",
          "IsStatic": false,
          "ParameterCount": 1
        }
      ]
    }
  ]
}
```

---

## File: BindingEmitter.cs

### Purpose
Generates `bindings.json` files with CLR-to-TypeScript name mappings. Used by runtime for binding and Tsonic compiler for code generation.

### Record: NamespaceBindings
```csharp
public sealed record NamespaceBindings
{
    public required string Namespace { get; init; }
    public required List<TypeBinding> Types { get; init; }
}
```

### Record: TypeBinding
```csharp
public sealed record TypeBinding
{
    public required string ClrName { get; init; }           // "System.Collections.Generic.List`1"
    public required string TsEmitName { get; init; }        // "List_1"
    public required string AssemblyName { get; init; }      // "System.Private.CoreLib"
    public required int MetadataToken { get; init; }        // 0 for types
    public required List<MethodBinding> Methods { get; init; }
    public required List<PropertyBinding> Properties { get; init; }
    public required List<FieldBinding> Fields { get; init; }
    public required List<EventBinding> Events { get; init; }
    public required List<ConstructorBinding> Constructors { get; init; }
}
```

### Record: MethodBinding
```csharp
public sealed record MethodBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string CanonicalSignature { get; init; }    // From StableId
    public required string NormalizedSignature { get; init; }   // Universal format
    public required string EmitScope { get; init; }
    public required int Arity { get; init; }
    public required int ParameterCount { get; init; }
}
```

### Record: PropertyBinding
```csharp
public sealed record PropertyBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string CanonicalSignature { get; init; }
    public required string NormalizedSignature { get; init; }
    public required string EmitScope { get; init; }
    public required bool IsIndexer { get; init; }
    public required bool HasGetter { get; init; }
    public required bool HasSetter { get; init; }
}
```

### Record: FieldBinding
```csharp
public sealed record FieldBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required bool IsReadOnly { get; init; }
}
```

### Record: EventBinding
```csharp
public sealed record EventBinding
{
    public required string ClrName { get; init; }
    public required string TsEmitName { get; init; }
    public required int MetadataToken { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
}
```

### Record: ConstructorBinding
```csharp
public sealed record ConstructorBinding
{
    public required int MetadataToken { get; init; }
    public required string CanonicalSignature { get; init; }
    public required string NormalizedSignature { get; init; }
    public required bool IsStatic { get; init; }
    public required int ParameterCount { get; init; }
}
```

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates bindings via `GenerateBindings()`
- Writes to `output/{namespace}/bindings.json`

### Method: GenerateBindings()
```csharp
private static NamespaceBindings GenerateBindings(BuildContext ctx, NamespaceEmitOrder nsOrder)
```
**What it does:**
- Creates `NamespaceBindings` with namespace name
- For each type in `nsOrder.OrderedTypes`, calls `GenerateTypeBinding()`

### Method: GenerateTypeBinding()
```csharp
private static TypeBinding GenerateTypeBinding(TypeSymbol type, BuildContext ctx)
```
**What it does:**
- Gets final TypeScript name from `ctx.Renamer.GetFinalTypeName(type)`
- Includes **ALL members** (ClassSurface, StaticSurface, AND ViewOnly)
- ViewOnly members get view-scoped names (e.g., `"IEnumerable_1$view$GetEnumerator"`)

**Key Decision:**
- Bindings include ViewOnly members (unlike declarations which only emit to views)
- This allows runtime to bind to explicit interface implementations

### Output Format Example

```json
{
  "Namespace": "System.Collections.Generic",
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "AssemblyName": "System.Private.CoreLib",
      "MetadataToken": 0,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "MetadataToken": 100663359,
          "CanonicalSignature": "Add(!0):System.Void",
          "NormalizedSignature": "Add(T):System.Void",
          "EmitScope": "ClassSurface",
          "Arity": 0,
          "ParameterCount": 1
        },
        {
          "ClrName": "GetEnumerator",
          "TsEmitName": "IEnumerable_1$view$GetEnumerator",
          "MetadataToken": 100663360,
          "CanonicalSignature": "GetEnumerator():System.Collections.Generic.IEnumerator`1<!0>",
          "NormalizedSignature": "GetEnumerator():System.Collections.Generic.IEnumerator`1<T>",
          "EmitScope": "ViewOnly",
          "Arity": 0,
          "ParameterCount": 0
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": []
    }
  ]
}
```

---

## File: ModuleStubEmitter.cs

### Purpose
Generates `index.js` stub files that throw at runtime. Prevents accidental execution while allowing TypeScript type checking.

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, EmissionPlan plan, string outputDirectory)
```
**What it does:**
- Iterates through `plan.EmissionOrder.Namespaces`
- For each namespace, generates stub via `GenerateStub()`
- Writes to `output/{namespace}/index.js`

### Method: GenerateStub()
```csharp
private static string GenerateStub(string namespaceName)
```
**What it does:**
- Creates JavaScript file with `throw new Error(...)` statement
- Error message explains this is type-only module requiring .NET runtime

### Output Format Example

```javascript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Module Stub - Do Not Execute

throw new Error(
  'Cannot import CLR namespace System.Collections.Generic in JavaScript runtime. ' +
  'This module provides TypeScript type definitions only. ' +
  'Actual implementation requires .NET runtime via Tsonic compiler.'
);
```

---

## File: SupportTypesEmitter.cs

### Purpose
Generates centralized `_support/types.d.ts` with marker types for unsafe CLR constructs. Emitted once for entire generation, not per-namespace.

### Method: Emit()
```csharp
public static void Emit(BuildContext ctx, string outputDirectory)
```
**What it does:**
- Creates `_support/` directory
- Generates content via `GenerateSupportTypes()`
- Writes to `output/_support/types.d.ts`

### Method: GenerateSupportTypes()
```csharp
private static string GenerateSupportTypes()
```
**What it does:**
- Emits `TSUnsafePointer<T>` type for pointer types (void*, int*, T*)
- Emits `TSByRef<T>` type for ref/out/in parameters

**Key Design:**
- `TSUnsafePointer<T>` erases to `unknown` for type safety (forces explicit handling)
- `TSByRef<T>` provides structural access via `.value` property
- Both use unique symbols for branding (maintains identity for auditing)

### Output Format Example

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Support Types Module
//
// These are opaque placeholders for CLR constructs that have no TS equivalent.
// They intentionally erase to `unknown` to keep the API sound.

/**
 * Marker type for C# pointer types (void*, int*, T*, etc.).
 * Erases to `unknown` for type safety - forces explicit handling.
 * The generic parameter preserves information about the pointed-to type.
 * Branded with unique symbol to maintain identity for auditing.
 */
export type TSUnsafePointer<T> = unknown & { readonly __tsbindgenPtr?: unique symbol };

/**
 * Marker type for C# ref/out/in parameters.
 * Provides structural access via `.value` to match C# semantics.
 * Branded with unique symbol to maintain identity for auditing.
 * Example: `method(arg: TSByRef<int>)` → caller uses `arg.value`
 */
export type TSByRef<T> = { value: T } & { readonly __tsbindgenByRef?: unique symbol };
```

---

## File: TypeMap.cs

### Purpose
Maps CLR built-in types to TypeScript types. Short-circuits graph lookups for primitives and special types. **CRITICAL:** Must be checked BEFORE TypeIndex lookup to avoid PG_LOAD_001 false positives.

### Method: TryMapBuiltin()
```csharp
public static bool TryMapBuiltin(string fullName, out string tsType)
```
**What it does:**
- Returns `true` if `fullName` is a known built-in type
- Sets `tsType` to the corresponding TypeScript type
- Returns `false` for non-built-in types

**Mappings:**

| CLR Type | TypeScript Type | Notes |
|----------|-----------------|-------|
| `System.Void` | `void` | |
| `System.Boolean` | `boolean` | |
| `System.String` | `string` | |
| `System.Object` | `any` | Maximum compatibility |
| `System.Char` | `string` | TS has no char type |
| `System.SByte` | `sbyte` | Branded type |
| `System.Byte` | `byte` | Branded type |
| `System.Int16` | `short` | Branded type |
| `System.UInt16` | `ushort` | Branded type |
| `System.Int32` | `int` | Branded type |
| `System.UInt32` | `uint` | Branded type |
| `System.Int64` | `long` | Branded type |
| `System.UInt64` | `ulong` | Branded type |
| `System.IntPtr` | `nint` | Branded type |
| `System.UIntPtr` | `nuint` | Branded type |
| `System.Single` | `float` | Branded type |
| `System.Double` | `double` | Branded type |
| `System.Decimal` | `decimal` | Branded type |
| `System.Array` | `any[]` | Base array type |
| `System.ValueType` | `any` | Base value type |
| `System.Enum` | `number` | Base enum type |
| `System.Delegate` | `Function` | |
| `System.MulticastDelegate` | `Function` | |

### Method: IsUnsupportedSpecialForm()
```csharp
public static bool IsUnsupportedSpecialForm(string fullName, bool isPointer, bool isByRef, bool isFunctionPointer)
```
**What it does:**
- Returns `true` if type is pointer, byref, or function pointer
- These require special handling or substitution

### Method: MapUnsupportedSpecialForm()
```csharp
public static string MapUnsupportedSpecialForm(string fullName, bool isPointer, bool isByRef, bool isFunctionPointer, bool allowUnsafeMaps)
```
**What it does:**
- If `allowUnsafeMaps` is `false`, throws exception
- If `allowUnsafeMaps` is `true`, returns `"any"`

### Method: IsBrandedPrimitive()
```csharp
public static bool IsBrandedPrimitive(string fullName)
```
**What it does:**
- Returns `true` for numeric types that should use branded syntax
- These are emitted as type aliases in file preamble

---

## File: TypeNameResolver.cs

### Purpose
Single source of truth for resolving TypeScript identifiers from TypeReferences. Uses the Renamer to ensure imports and declarations use identical names.

### Constructor
```csharp
public TypeNameResolver(BuildContext ctx, SymbolGraph graph)
```
**What it does:**
- Stores `BuildContext` (for Renamer access)
- Stores `SymbolGraph` (for TypeIndex lookups)

### Method: For(TypeSymbol)
```csharp
public string For(Model.Symbols.TypeSymbol type)
```
**What it does:**
- Returns final TypeScript identifier for a `TypeSymbol`
- Directly queries `ctx.Renamer.GetFinalTypeName(type)`

### Method: ResolveTypeName(NamedTypeReference)
```csharp
public string ResolveTypeName(NamedTypeReference named)
```
**What it does:**
- Wrapper for `For(NamedTypeReference)` to provide consistent API

### Method: For(NamedTypeReference)
```csharp
public string For(NamedTypeReference named)
```
**What it does:**
1. **Try TypeMap FIRST** - Short-circuit built-in types before graph lookup (prevents PG_LOAD_001)
2. **Look up TypeSymbol in graph** - Uses StableId (`{AssemblyName}:{FullName}`)
3. **If not in graph** - Type is external (from another assembly), sanitize CLR name
4. **Get final TypeScript name from Renamer** - Single source of truth

**Algorithm:**
```csharp
// 1. Try TypeMap (built-ins like System.Int32 → int)
if (TypeMap.TryMapBuiltin(named.FullName, out var builtinType))
    return builtinType;

// 2. Look up in graph
var stableId = $"{named.AssemblyName}:{named.FullName}";
if (!_graph.TypeIndex.TryGetValue(stableId, out var typeSymbol))
{
    // External type - sanitize CLR name
    return SanitizeClrName(simpleName);
}

// 3. Get final name from Renamer
return _ctx.Renamer.GetFinalTypeName(typeSymbol);
```

### Method: SanitizeClrName()
```csharp
private static string SanitizeClrName(string clrName)
```
**What it does:**
- Replaces generic arity backtick: `List`1` → `List_1`
- Replaces nested type separator: `Foo+Bar` → `Foo_Bar`
- Removes invalid TypeScript identifier characters

### Method: TryMapPrimitive()
```csharp
public static string? TryMapPrimitive(string clrFullName)
```
**What it does:**
- Static helper that calls `TypeMap.TryMapBuiltin()`
- Returns `null` if not a primitive

### Method: IsPrimitive()
```csharp
public static bool IsPrimitive(string clrFullName)
```
**What it does:**
- Returns `true` if type is a primitive that doesn't need imports

---

## File: Printers/ClassPrinter.cs

### Purpose
Prints TypeScript class declarations from TypeSymbol. Handles classes, structs, static classes, enums, delegates, and interfaces.

### Method: Print()
```csharp
public static string Print(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- **GUARD:** Never prints non-public types (logs rejection if attempted)
- Dispatches to specialized printer based on `type.Kind`:
  - `TypeKind.Class` → `PrintClass()`
  - `TypeKind.Struct` → `PrintStruct()`
  - `TypeKind.StaticNamespace` → `PrintStaticClass()`
  - `TypeKind.Enum` → `PrintEnum()`
  - `TypeKind.Delegate` → `PrintDelegate()`
  - `TypeKind.Interface` → `PrintInterface()`

### Method: PrintInstance()
```csharp
public static string PrintInstance(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints class/struct with `$instance` suffix (for companion views pattern)
- Used when type has explicit interface views
- Only classes and structs support this (other types fallback to normal Print)

### Method: PrintClass()
```csharp
private static string PrintClass(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, bool instanceSuffix = false)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Adds `$instance` suffix if requested
3. Emits class modifiers (`abstract` if abstract)
4. Emits generic parameters with constraints
5. Emits base class (`extends BaseClass`, skips Object/ValueType)
6. Emits interfaces (`implements IFoo, IBar`)
7. Calls `EmitMembers()` to emit body

### Method: PrintStruct()
```csharp
private static string PrintStruct(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx, bool instanceSuffix = false)
```
**What it does:**
- Structs emit as classes (metadata notes value semantics)
- Same as `PrintClass()` but no `abstract` modifier, no base class

### Method: PrintStaticClass()
```csharp
private static string PrintStaticClass(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits as `abstract class TypeName { ... }`
- Calls `EmitStaticMembers()` to emit static-only members

### Method: PrintEnum()
```csharp
private static string PrintEnum(TypeSymbol type, BuildContext ctx)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Emits `enum TypeName { ... }`
3. Iterates through const fields (enum members)
4. Gets final member name from Renamer (using `ClassStatic` scope)
5. Emits `Name = Value,` for each member

### Method: PrintDelegate()
```csharp
private static string PrintDelegate(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Emits `type TypeName<...> = ...`
3. Finds `Invoke` method
4. Emits function signature: `(a: int, b: string) => void`

### Method: PrintInterface()
```csharp
private static string PrintInterface(TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Gets final TypeScript name from Renamer
2. Emits `interface TypeName<...> extends ... { ... }`
3. Calls `EmitInterfaceMembers()` to emit body

### Method: EmitMembers()
```csharp
private static void EmitMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits instance members:
  - Constructors (non-static)
  - Fields (non-static, ClassSurface only)
  - Properties (non-static, ClassSurface only)
  - Methods (non-static, ClassSurface only)
- Calls `EmitStaticMembers()` for static members
- Uses `ScopeFactory.ClassInstance(type)` for member name resolution

### Method: EmitStaticMembers()
```csharp
private static void EmitStaticMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits static members:
  - Fields (static, non-const, ClassSurface or StaticSurface)
  - Const fields (as `static readonly`, ClassSurface or StaticSurface)
  - Properties (static, ClassSurface or StaticSurface)
  - Methods (static, ClassSurface or StaticSurface)
- Uses `ScopeFactory.ClassStatic(type)` for member name resolution

### Method: EmitInterfaceMembers()
```csharp
private static void EmitInterfaceMembers(StringBuilder sb, TypeSymbol type, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits interface members:
  - Properties (non-static, ClassSurface only) - static not supported in TS interfaces
  - Methods (non-static, ClassSurface only) - static not supported in TS interfaces
- Uses `ScopeFactory.ClassSurface()` for member name resolution

### Method: PrintGenericParameter()
```csharp
private static string PrintGenericParameter(GenericParameterSymbol gp, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Emits generic parameter with constraints
- Single constraint: `T extends IFoo`
- Multiple constraints: `T extends IFoo & IBar` (intersection)

---

## File: Printers/MethodPrinter.cs

### Purpose
Prints TypeScript method signatures from MethodSymbol. Handles generic methods, parameters, return types, and modifiers.

### Method: Print()
```csharp
public static string Print(MethodSymbol method, TypeSymbol declaringType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Gets final TS name from Renamer using `ClassSurface` scope
2. Emits modifiers (`static`, `abstract`) - SKIPPED for interface members
3. Emits method name
4. Emits generic parameters with constraints
5. Emits parameters
6. Emits return type

**Key Decision:**
- Interface members don't get `static`/`abstract` modifiers (TS doesn't support static interface members)

### Method: PrintGenericParameter()
```csharp
private static string PrintGenericParameter(GenericParameterSymbol gp, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints generic parameter with constraints
- Single constraint: `T extends IFoo`
- Multiple constraints: `T extends IFoo & IBar`

### Method: PrintParameter()
```csharp
private static string PrintParameter(ParameterSymbol param, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints parameter name
- Adds `?` for optional parameters (has default value)
- Handles ref/out parameters: `{ value: T }` wrapper (metadata tracks semantics)
- Handles params parameters: caller adds `...` prefix

### Method: PrintWithParamsExpansion()
```csharp
public static string PrintWithParamsExpansion(MethodSymbol method, TypeSymbol declaringType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Converts params array to rest parameter syntax
- Example: `Add(items: T[])` → `Add(...items: T[])`
- Only applies to last parameter if `IsParams` is true

### Method: PrintOverloads()
```csharp
public static IEnumerable<string> PrintOverloads(IEnumerable<MethodSymbol> overloads, TypeSymbol declaringType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints multiple method overloads (same name, different signatures)
- Yields one string per overload

### Method: PrintAsPropertyAccessor()
```csharp
public static string PrintAsPropertyAccessor(MethodSymbol method, bool isGetter, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints method as property getter/setter
- Extracts property name from method name (`get_Foo` → `Foo`)
- Used for interface property accessors

---

## File: Printers/TypeRefPrinter.cs

### Purpose
Prints TypeScript type references from TypeReference model. Handles all type constructs: named, generic parameters, arrays, pointers, byrefs, nested. **CRITICAL:** Uses TypeNameResolver to ensure printed names match imports (single source of truth).

### Method: Print()
```csharp
public static string Print(TypeReference typeRef, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Dispatches to specialized printer based on type reference kind:
  - `PlaceholderTypeReference` → `PrintPlaceholder()` (emits warning, returns `any`)
  - `NamedTypeReference` → `PrintNamed()`
  - `GenericParameterReference` → `PrintGenericParameter()`
  - `ArrayTypeReference` → `PrintArray()`
  - `PointerTypeReference` → `PrintPointer()`
  - `ByRefTypeReference` → `PrintByRef()`
  - `NestedTypeReference` → `PrintNested()`

### Method: PrintPlaceholder()
```csharp
private static string PrintPlaceholder(PlaceholderTypeReference placeholder, BuildContext ctx)
```
**What it does:**
- Emits diagnostic warning (placeholders should never reach output)
- Returns `"any"` as fallback

### Method: PrintNamed()
```csharp
private static string PrintNamed(NamedTypeReference named, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
1. Tries to map CLR primitive via `TypeNameResolver.TryMapPrimitive()` (short-circuit)
2. Gets final TypeScript name from `resolver.ResolveTypeName(named)`
3. Validates non-empty name (emits warning if empty)
4. Handles generic type arguments recursively
5. Returns `TypeName<T, U>` or plain `TypeName`

**Key Algorithm:**
```csharp
// 1. Map primitive (System.Int32 → int)
var primitiveType = TypeNameResolver.TryMapPrimitive(named.FullName);
if (primitiveType != null) return primitiveType;

// 2. Get final name from resolver (handles both graph types and external types)
var baseName = resolver.ResolveTypeName(named);

// 3. HARDENING: Validate non-empty
if (string.IsNullOrWhiteSpace(baseName))
{
    ctx.Diagnostics.Warning(...);
    return "unknown";
}

// 4. Handle generic arguments recursively
if (named.TypeArguments.Count > 0)
{
    var args = string.Join(", ", named.TypeArguments.Select(arg => Print(arg, resolver, ctx)));
    return $"{baseName}<{args}>";
}

return baseName;
```

### Method: PrintGenericParameter()
```csharp
private static string PrintGenericParameter(GenericParameterReference gp)
```
**What it does:**
- Returns generic parameter name as-is: `T`, `U`, `TKey`, `TValue`

### Method: PrintArray()
```csharp
private static string PrintArray(ArrayTypeReference arr, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Single-dimensional: `T[]`
- Multi-dimensional: `Array<Array<T>>` (nested)

### Method: PrintPointer()
```csharp
private static string PrintPointer(PointerTypeReference ptr, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Returns `TSUnsafePointer<T>` where T is the pointee type
- Preserves type information while being type-safe (erases to `unknown`)

### Method: PrintByRef()
```csharp
private static string PrintByRef(ByRefTypeReference byref, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Returns `TSByRef<T>` where T is the referenced type
- Provides structural access via `.value` property

### Method: PrintNested()
```csharp
private static string PrintNested(NestedTypeReference nested, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Nested types use resolver just like named types
- The `FullReference` is a `NamedTypeReference` that the resolver handles correctly

### Helper Methods

#### PrintList()
```csharp
public static string PrintList(IEnumerable<TypeReference> typeRefs, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints comma-separated list of type references
- Used for generic parameter lists, method parameters

#### PrintNullable()
```csharp
public static string PrintNullable(TypeReference typeRef, bool isNullable, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints type with optional nullability: `T | null`

#### PrintReadonlyArray()
```csharp
public static string PrintReadonlyArray(TypeReference elementType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints `ReadonlyArray<T>` for IEnumerable<T> mappings

#### PrintPromise()
```csharp
public static string PrintPromise(TypeReference resultType, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints `Promise<T>` for Task<T> mappings

#### PrintTuple()
```csharp
public static string PrintTuple(IReadOnlyList<TypeReference> elementTypes, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints tuple type: `[T1, T2, T3]`

#### PrintUnion()
```csharp
public static string PrintUnion(IReadOnlyList<TypeReference> types, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints union type: `T1 | T2 | T3`

#### PrintIntersection()
```csharp
public static string PrintIntersection(IReadOnlyList<TypeReference> types, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints intersection type: `T1 & T2 & T3`

#### PrintTypeof()
```csharp
public static string PrintTypeof(TypeReference typeRef, TypeNameResolver resolver, BuildContext ctx)
```
**What it does:**
- Prints typeof expression: `typeof ClassName`

---

## Output File Format Examples

### 1. index.d.ts (Facade)

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Facade - Public API Surface

// Import internal declarations
import * as Internal from './internal/index';

// Import dependencies
import * as System from '../System/index';

// Re-export namespace
export import Generic = Internal.System.Collections.Generic;

// Individual type exports for convenience
export type List_1 = Internal.System.Collections.Generic.List_1;
export type Dictionary_2 = Internal.System.Collections.Generic.Dictionary_2;
export type IEnumerable_1 = Internal.System.Collections.Generic.IEnumerable_1;
```

### 2. internal/index.d.ts (Declarations)

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Private.CoreLib

// Branded primitive types for CLR numeric types
export type sbyte = number & { __brand: "sbyte" };
export type byte = number & { __brand: "byte" };
export type int = number & { __brand: "int" };
// ... all primitives ...

// Import support types for unsafe CLR constructs
import type { TSUnsafePointer, TSByRef } from "../_support/types";

// Import types from other namespaces
import type { Object, ValueType } from "../System/internal/index";

export namespace System.Collections.Generic {
    export class List_1$instance<T> {
        constructor(capacity: int);
        readonly Count: int;
        Add(item: T): void;
        GetEnumerator(): IEnumerator_1<T>;
    }

    export interface __List_1$views<T> {
        readonly IEnumerable_1$view: IEnumerable_1<T>;
    }

    export type List_1<T> = List_1$instance<T> & __List_1$views<T>;

    export interface IEnumerable_1<T> {
        GetEnumerator(): IEnumerator_1<T>;
    }
}
```

### 3. internal/metadata.json

```json
{
  "Namespace": "System.Collections.Generic",
  "ContributingAssemblies": [
    "System.Private.CoreLib"
  ],
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "Kind": "Class",
      "Accessibility": "Public",
      "IsAbstract": false,
      "IsSealed": false,
      "IsStatic": false,
      "Arity": 1,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "NormalizedSignature": "Add(T):System.Void",
          "Provenance": "Direct",
          "EmitScope": "ClassSurface",
          "IsStatic": false,
          "IsAbstract": false,
          "IsVirtual": false,
          "IsOverride": false,
          "IsSealed": false,
          "Arity": 0,
          "ParameterCount": 1
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": []
    }
  ]
}
```

### 4. bindings.json

```json
{
  "Namespace": "System.Collections.Generic",
  "Types": [
    {
      "ClrName": "System.Collections.Generic.List`1",
      "TsEmitName": "List_1",
      "AssemblyName": "System.Private.CoreLib",
      "MetadataToken": 0,
      "Methods": [
        {
          "ClrName": "Add",
          "TsEmitName": "Add",
          "MetadataToken": 100663359,
          "CanonicalSignature": "Add(!0):System.Void",
          "NormalizedSignature": "Add(T):System.Void",
          "EmitScope": "ClassSurface",
          "Arity": 0,
          "ParameterCount": 1
        }
      ],
      "Properties": [],
      "Fields": [],
      "Events": [],
      "Constructors": []
    }
  ]
}
```

### 5. index.js (Stub)

```javascript
// Generated by tsbindgen - Single-Phase Architecture
// Namespace: System.Collections.Generic
// Module Stub - Do Not Execute

throw new Error(
  'Cannot import CLR namespace System.Collections.Generic in JavaScript runtime. ' +
  'This module provides TypeScript type definitions only. ' +
  'Actual implementation requires .NET runtime via Tsonic compiler.'
);
```

### 6. _support/types.d.ts

```typescript
// Generated by tsbindgen - Single-Phase Architecture
// Support Types Module
//
// These are opaque placeholders for CLR constructs that have no TS equivalent.
// They intentionally erase to `unknown` to keep the API sound.

/**
 * Marker type for C# pointer types (void*, int*, T*, etc.).
 * Erases to `unknown` for type safety - forces explicit handling.
 * The generic parameter preserves information about the pointed-to type.
 * Branded with unique symbol to maintain identity for auditing.
 */
export type TSUnsafePointer<T> = unknown & { readonly __tsbindgenPtr?: unique symbol };

/**
 * Marker type for C# ref/out/in parameters.
 * Provides structural access via `.value` to match C# semantics.
 * Branded with unique symbol to maintain identity for auditing.
 * Example: `method(arg: TSByRef<int>)` → caller uses `arg.value`
 */
export type TSByRef<T> = { value: T } & { readonly __tsbindgenByRef?: unique symbol };
```

---

## Key Design Decisions

### 1. Companion Views Pattern

**Problem:** TypeScript doesn't support structural intersection for class implementation checking.

**Solution:**
- Emit `TypeName$instance` class with ClassSurface members
- Emit `__TypeName$views` interface with ViewOnly members
- Emit `type TypeName = TypeName$instance & __TypeName$views`

**Benefits:**
- Class surface remains clean (no view member clutter)
- Views are type-checked via intersection
- Consumers get both class and view members via single type

### 2. Branded Primitive Types

**Problem:** TypeScript `number` type can't distinguish `int` vs `float` vs `decimal`.

**Solution:**
- Emit branded type aliases: `type int = number & { __brand: "int" };`
- All namespaces get these (needed for cross-namespace references)

**Benefits:**
- Type safety for CLR numeric types
- No runtime overhead (erases to `number`)
- Intentional misuse detection (can't pass `float` where `int` expected)

### 3. Unsafe Type Markers

**Problem:** TypeScript has no pointers or ref parameters.

**Solution:**
- Centralized `_support/types.d.ts` with marker types
- `TSUnsafePointer<T>` for pointers (erases to `unknown`)
- `TSByRef<T>` for ref/out/in (structural `{ value: T }`)

**Benefits:**
- Type-safe (forces explicit handling)
- Preserves type information
- Branded for auditing
- Single import location

### 4. EmitScope Filtering

**Problem:** Not all members should appear in declarations (some are view-only).

**Solution:**
- `ClassSurface` members → class body
- `StaticSurface` members → static members
- `ViewOnly` members → companion views interface

**Benefits:**
- Clean separation of concerns
- No duplicate members in class surface
- Explicit interface implementations in views

### 5. TypeNameResolver Single Source of Truth

**Problem:** Name mismatches between imports and declarations cause errors.

**Solution:**
- All name resolution goes through `TypeNameResolver`
- Resolver queries `Renamer` for final names
- Never use CLR names directly in printers

**Benefits:**
- Guaranteed name consistency
- Suffix handling in one place
- Easy to audit (single code path)

---

## Summary

The **Emit Phase** is the final phase that generates all output files from the validated `EmissionPlan`. It consists of multiple specialized emitters:

1. **FacadeEmitter** - Public-facing facades with re-exports
2. **InternalIndexEmitter** - Actual TypeScript declarations with companion views
3. **MetadataEmitter** - CLR-specific metadata for Tsonic compiler
4. **BindingEmitter** - CLR-to-TypeScript name mappings for runtime
5. **ModuleStubEmitter** - JavaScript stubs that prevent execution
6. **SupportTypesEmitter** - Centralized unsafe type markers

All emitters use:
- **TypeNameResolver** for consistent type names (single source of truth)
- **Renamer** for final TypeScript identifiers (suffix handling)
- **EmitScope** for member filtering (ClassSurface/StaticSurface/ViewOnly)
- **EmitOrder** for deterministic output (stable across runs)

The output includes:
- **TypeScript declarations** - `.d.ts` files with type definitions
- **Metadata sidecars** - `.json` files with CLR information
- **Binding metadata** - `.json` files with name mappings
- **Module stubs** - `.js` files that throw at runtime
- **Support types** - Centralized marker types for unsafe constructs

All output is deterministic, type-safe, and respects the single-phase architecture's guarantees.
